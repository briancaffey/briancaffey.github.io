[{"_path":"/2020/11/29/weekend-project-update-open-sec-data","_dir":"29","_draft":false,"_partial":false,"_locale":"","title":"Weekend project update: Open SEC Data","description":"This project uses Django, DRF and Celery to read public SEC filings from sec.gov, build it into an API which is consumed through a Vue.js application.","date":"2020-11-29T00:00:00.000Z","image":"/static/sec-update.jpg","tags":["django","vue","data","api","gitlab","docker","celery"],"body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Here's an early look at a project I have been working on to practice some Django and Vue.js concepts: Open SEC Data."}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://opensecdata.ga","rel":["nofollow"]},"children":[{"type":"text","value":"https://opensecdata.ga"}]},{"type":"text","value":" (project staging website, deployed to docker swarm cluster running on DigitalOcean)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://gitlab.com/briancaffey/sec-filings-app","rel":["nofollow"]},"children":[{"type":"text","value":"https://gitlab.com/briancaffey/sec-filings-app"}]},{"type":"text","value":" (main repository, requires GitLab account)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/briancaffey/sec-filings-app","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/briancaffey/sec-filings-app"}]},{"type":"text","value":" (mirror, no account required to view)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This project uses Django, DRF and Celery to read public SEC filings from "},{"type":"element","tag":"a","props":{"href":"https://www.sec.gov/Archives/edgar/full-index/","rel":["nofollow"]},"children":[{"type":"text","value":"sec.gov"}]},{"type":"text","value":", build it into an API which is consumed through a Vue.js application. I'm currently focused on 13F filings which are required for large US investment funds managing over $100 million USD. There is data dating back to 1993 and it is published quarterly."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Here are some of the things I'm focusing on in this project in no particular order:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Getting better at Django REST Framework. This project has been helping me apply some of the parts of DRF that I have found difficult. I'm currently using ViewSets which feels function-based views inside of class-based views. They are flexible, but I would like to add more abstraction with filtering"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Django admin. While this project primarily uses Django as a REST API with Django REST Framework, I have tried to take advantage of the Django admin to build out helpful views that can be used to spot check the data I'm creating. Most of my API is read-only, this makes things pretty simple."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Moderately complex paginated data tables with Vue. I work with lots of paginated table data, and I think there is a better way to do abstract some of the repeated logic that I use (getting and setting current page, rows per page). I'm using Vuex, and I have heard of module factories, but I'm thinking that there will be a better way to do this when Vue 3 officially comes to Quasar Framework (Quasar is a Vue.js framework)."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Session authentication with DRF. There are a lot of guides showing how to use JWT and Token Authentication for DRF with Javascript frontends. The DRF recommends using Session Authentication for such use cases as a web-base Javascript client, so I hope I can promote some best practices around how to use Django's built-in session authentication for use with the Django REST Framework using an HttpOnly session cookie. I also understand that all security decisions have trade-offs, and I'm trying to understand what trade-offs come with handling authentication in this way."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Social authentication. I have previously setup social authentication with Google, Facebook and GitHub using Python Social Auth. I think it is a great package, and it adds a lot of flexibility with it's concept of pipelines, but I haven't done much with these yet, so I'm hoping to dig in further and better understand how I can make better use of social authentication in my app. This app uses Linkedin 0Auth2 with a custom user model. Logging in with Linkedin account gives you the ability to request an API Token (Django REST Framework's Token) to access the public API."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Automatic API documentation with OpenAPI. Swagger/OpenAPI seems like nice way to document and API, so I'm hoping to build best practices around how to document a DRF API automatically with OpenAPI and Swagger UI."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CI/CD with GitLab and docker swarm. I will admit that I am huge GitLab fan. I love how flexible their CI/CD pipelines are. Being a docker fan as well, I chose to use docker swarm for this project to keep things simple and straightforward. I think one under-appreciate feature of docker is being able to set "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DOCKER_HOST"}]},{"type":"text","value":" to an SSH connection, such as "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ssh://root@123.456.789.10"}]},{"type":"text","value":". This let's you control the remote docker host without needing to SSH to it first, and it is also how I'm able to deploy and run management commands \"manually\" through the GitLab UI."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Productive development environment. To start the project, you only need to run docker-compose up (after copying "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":".env.template"}]},{"type":"text","value":" to "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":".env"}]},{"type":"text","value":" in the root directory for storing sensitive data outside of git such as LinkedIn OAuth2 keys). The development environment is very similar to how this project runs in production with some additional utilities for monitoring and debugging such as pgadmin4, flower (for celery), redis commander (a GUI for viewing redis databases), Django debug toolbar (a must have for any Django project, I believe), runserver_plus with Werkzeug, and others. Also, the backend and frontend hot reload automatically with the help of webpack for Vue and watchdog for Django and Celery."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Automatic TLS certificate generation with Traefik. For a simple project in docker swarm, I'm really happy with how simple it is to request TLS certificates from Let's Encrypt automatically with Traefik. There are no scripts, cron jobs or one-time setup jobs, it just seems to work out of the box if configured correctly."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Testing with pytest. I have only been trying to test most of my API views so far. I really like using factory with pytest, so I use that in most of my tests."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"That's all I have for now. I have a long list of questions, things I want to improve, add and experiment with, here are just a few that come to mind:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Frontend testing. I don't have any component testing or e2d tests, so this would be good to add eventually. Since I'm using a component library and my app uses these components directly, I'm not exactly sure how much testing I should be doing."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Data verification/validation. There are a lot of site that do provide similar data, WhaleWisdom is the biggest one that I know of. Once I get more data built on the site it would be good to spot check some of the values. There are some nuances to the filing data that I haven't addressed, such as Amendment filings and additions."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Calculating period changes. One of the features that I'm not sure how best to implement is the ability to sort holdings for a filer in a given period on the percent increase from the last period. One way would be to add these as additional fields to the Holding model and then calculate these values as I process the data in celery. If I process the data from recent periods to later periods, I will have to update these values once the previous period has been processed, so it would be an additional check to do. I'll probably post this question here in more detail later. Here's "},{"type":"element","tag":"a","props":{"href":"https://whalewisdom.com/filer/ubs-ag#tabholdings_tab_link","rel":["nofollow"]},"children":[{"type":"text","value":"an example of what this means from WhaleWisdom"}]},{"type":"text","value":"."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Accessing LinkedIn profile data to populate fields on my CustomUser model."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Scaling? I have a lot more experience with deploying projects to AWS which is built around the ability to scale. I don't know a project on DigitalOcean would be scaled automatically. A single node docker swarm cluster while take some time to process all of the data. I would probably be better of scaling vertically with much bigger droplets and higher celery concurrency."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Docker swarm secrets. I'm currently using environment variables to pass secrets stored in GitLab CI when I build images and deploy to docker swarm. I would like to learn how to properly use swarm secrets and work them into my CI/CD pipeline."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"As I mentioned above, I'm also interested in updating this project to Vue3 and to apply some of its new features to this project."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Use pipenv, poetry or some other way of pinning secondary python dependencies. Does anyone have a recommendation on how best to do this with docker. I have always thought that docker "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"is"}]},{"type":"text","value":" the virtual environment, but I realize that some versions of indirect dependencies may change when pip installing without using a lockfile similar to "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"package-lock.json"}]},{"type":"text","value":"."}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:2020:11:29:weekend-project-update-open-sec-data.md","_source":"content","_file":"2020/11/29/weekend-project-update-open-sec-data.md","_stem":"2020/11/29/weekend-project-update-open-sec-data","_extension":"md"},{"_path":"/2020/11/27/how-to-authenticate-django-rest-framework-from-vue-app-with-session-authentication-httponly-cookies","_dir":"27","_draft":false,"_partial":false,"_locale":"","title":"How to authenticate Django REST Framework API calls from a (Vue) JS client using Session Authentication and HttpOnly cookies","description":"This article will describe an authentication strategy using Django REST Framework with a Javascript frontend application. I'll be demonstrating this with Vue.js (Qusar Framework, using Vue 2), but the concepts should transfer to any other Javascript framework.","layout":"post","date":"2020-11-27T00:00:00.000Z","comments":true,"image":"/static/padlocks.jpg","tags":["django","vue","authentication","api"],"body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This article will describe an authentication strategy using Django REST Framework with a Javascript frontend application. I'll be demonstrating this with Vue.js (Qusar Framework, using Vue 2), but the concepts should transfer to any other Javascript framework."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Here's a GitLab repository for a project that I will be referencing throughout this article: "},{"type":"element","tag":"a","props":{"href":"https://gitlab.com/verbose-equals-true/django-postgres-vue-gitlab-ecs","rel":["nofollow"]},"children":[{"type":"text","value":"https://gitlab.com/verbose-equals-true/django-postgres-vue-gitlab-ecs"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When I first started learning about how to do authentication from a Vue client, I found "},{"type":"element","tag":"a","props":{"href":"https://blog.sqreen.com/authentication-best-practices-vue/","rel":["nofollow"]},"children":[{"type":"text","value":"this article from Sqreen"}]},{"type":"text","value":" which describes how to use JWT to authenticate a Vue application. The example uses a mocked backend, but it is a good proxy for what you would have if you were to use a library like "},{"type":"element","tag":"a","props":{"href":"https://github.com/SimpleJWT/django-rest-framework-simplejwt","rel":["nofollow"]},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"django-rest-framework-simplejwt"}]}]},{"type":"text","value":", which I have previously used with success in Django projects."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"JWT is an option for doing authentication with DRF "},{"type":"element","tag":"a","props":{"href":"https://www.django-rest-framework.org/api-guide/authentication/#json-web-token-authentication","rel":["nofollow"]},"children":[{"type":"text","value":"listed in the authentication documentation"}]},{"type":"text","value":", but the documentation doesn't recommend when or how to use JWT authentication."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Session authentication is mentioned as well:"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This authentication scheme uses Django's default session backend for authentication. Session authentication is appropriate for AJAX clients that are running in the same session context as your website."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In my project, both in local development and in production environments, I serve the API and the Javascript clients on the same domain. "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/api/*"}]},{"type":"text","value":" requests go to the API, and all other request paths route to the frontend client. In other scenarios such as using "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"https://mysite.com"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"https://api.mysite.com"}]},{"type":"text","value":" for hosting a frontend and API an different subdomains, there would need to be additional considerations for CORS, but since I have the frontend and the backend being served on the same domain (and same subdomain), this isn't a concern. You might need to watch out for this if your requirements are different."}]},{"type":"element","tag":"h2","props":{"id":"the-authentication-flow"},"children":[{"type":"text","value":"The authentication flow"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Now let's describe the login process at a high level."}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A user navigates to your site. There is currently nothing in the browser's "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"localStorage"}]},{"type":"text","value":" or cookies related to authentication."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The user navigates to the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Login"}]},{"type":"text","value":" page at "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/login"}]},{"type":"text","value":"."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Loading this Vue component makes a "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GET"}]},{"type":"text","value":" request to a special endpoint in our Django backend "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/api/login-set-cookie/"}]},{"type":"text","value":". This request returns a simple JSON message: "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"\"CSRF cookie set\""}]},{"type":"text","value":", and as the message says, the response sets a "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"csrf"}]},{"type":"text","value":" cookie on our browser."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Once the CSRF cookie is set by the response from "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/api/login-set-cookie/"}]},{"type":"text","value":", the user is presented with a login form and enters account credentials (email and password in my example, where email is the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"USERNAME_FIELD"}]},{"type":"text","value":" on my custom user model). Clicking \"Login\" dispatches a Vuex action that uses Axios to send a send a request to "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/api/login/"}]},{"type":"text","value":" with the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"csrf"}]},{"type":"text","value":" cookie set in a "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"X-CSRFToken"}]},{"type":"text","value":" header."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/api/login/"}]},{"type":"text","value":" is handled by the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"login_view"}]},{"type":"text","value":" view which uses two important functions from "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"django.contrib.auth"}]},{"type":"text","value":": "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"authenticate"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"login"}]},{"type":"text","value":". "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"authenticate"}]},{"type":"text","value":" gets the user from the provided credentials, and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"login"}]},{"type":"text","value":" sets a "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"sessionid"}]},{"type":"text","value":" HttpOnly cookie on the response."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"When the response from "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/api/login/"}]},{"type":"text","value":" comes back, two things happen: first the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"sessionid"}]},{"type":"text","value":" HttpOnly cookie is set on our browser. Second, we set a value in both Vuex and localStorage named "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"authenticated"}]},{"type":"text","value":" to "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"success"}]},{"type":"text","value":". We are not storing any sensitive information in this value. Instead, we are using this value to signal to the rest of our Vue application that the user has authenticated. Storing this in Vuex allows us to use global Vuex "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"getters"}]},{"type":"text","value":" so that we can change component state and other logic where authentication is concerned, such as route guards (for Vue router). We store it in localStorage so that when a new browser tab is opened, we can set the value of "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"authenticated"}]},{"type":"text","value":" in Vuex based on the value in localStorage. ("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"authenticated: localStorage.getItem(\"authenticated\") || \"\","}]},{"type":"text","value":")"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Since the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"sessionid"}]},{"type":"text","value":" cookie is HttpOnly, we can't use Javascript to interact with it, so when we want to logout the user we can't just delete the cookie. To logout the user, we make a request to "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/api/logout/"}]},{"type":"text","value":" when the user clicks on the logout button. The view for this endpoint does "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"logout(request)"}]},{"type":"text","value":". This returns a response with a new value for the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"sessionid"}]},{"type":"text","value":" cookie: "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Set-Cookie: sessionid=\"\"; expires=Thu, 01 Jan 1970 00:00:00 GMT; Max-Age=0; Path=/; SameSite=Lax"}]},{"type":"text","value":". Since the cookie's expiration is in the past, it is removed entirely. We also remove the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"authenticated"}]},{"type":"text","value":" localStorage item and set the Vuex store value of "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"authenticated"}]},{"type":"text","value":" to "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"''"}]},{"type":"text","value":" (which is falsey). This lets the Vue application know that user has been logged out. One consideration for this is that your user can't logout while offline."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"This repo also implements social authentication with the fantastic Python Social Auth library. I used Facebook, Google and GitHub, but there are lots of other providers you can choose from depending on what you need. This is a lengthy topic, and I recommend that you read "},{"type":"element","tag":"a","props":{"href":"https://www.toptal.com/django/integrate-oauth-2-into-django-drf-back-end","rel":["nofollow"]},"children":[{"type":"text","value":"How to Integrate OAuth 2 Into Your Django/DRF Back-end Without Going Insane"}]},{"type":"text","value":" on which I have based my implementation. Here's the short story of how this works. First, a user clicks on one of the social sign-in links. These links are the same for sign-in and sign-up."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The link has a few parts, here's an example: "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"https://github.com/login/oauth/authorize?client_id=r66bdfgsfsbferfef4&redirect_uri=http:%2F%2Flocalhost%2Fauth%2Fgithub%2Fcallback&login=&scope=user:email&state=ewori4t95k3vdzem"}]},{"type":"text","value":". The "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"client_id"}]},{"type":"text","value":" is the app we created to allow our users to sign in. When you create this app, you specify the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"redirect_uri"}]},{"type":"text","value":" in the configuration, and you reference that here as well. "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"scope"}]},{"type":"text","value":" specifies scope of access we are requesting from the user's social account. "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"state"}]},{"type":"text","value":" is used for security."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"When you click on the link above, you are redirected to GitHub and asked if you want to grant my GitHub application access to your account's associated email address. Clicking on \"Authorize\" then redirects you back to the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"redirect_uri"}]},{"type":"text","value":": "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"http://localhost/auth/github/callback?code=veroi3409e203ej&state=ewori4t95k3vdzem"}]},{"type":"text","value":". Notice the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"code"}]},{"type":"text","value":" parameter."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"When you navigate to "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/auth/github/callback"}]},{"type":"text","value":" on the Vue application, you see a message: \"Logging in with GitHub...\". On this page's "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"mounted"}]},{"type":"text","value":" method we call "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"handleOauthCallback"}]},{"type":"text","value":" which makes a request to our Django application: "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/api/social/github/?code=veroi3409e203ej"}]},{"type":"text","value":"."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"This API endpoint uses the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"exchange_token"}]},{"type":"text","value":" view which is where Python Social Auth starts to do the heavy lifting. First, we need to make an API request to GitHub ("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"https://github.com/login/oauth/access_token"}]},{"type":"text","value":") with the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"code"}]},{"type":"text","value":" as a URL parameter, then we pass the access code that this API call returns into Python Social Auth's "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"do_auth"}]},{"type":"text","value":" function to get our Django user. Finally, similar to the email/password login approach described above, we call "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"login(request, user)"}]},{"type":"text","value":" and return a simple JSON response: "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"{\"detail\": \"success\"}"}]},{"type":"text","value":". This will set the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"sessionid"}]},{"type":"text","value":" automatically when the response returns, and we can dispatch the same Vuex action "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"AUTH_SUCCESS"}]},{"type":"text","value":" to tell Vuex that a user has been logged in."}]}]},{"type":"element","tag":"h2","props":{"id":"discussion"},"children":[{"type":"text","value":"Discussion"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Using the default Django session authentication mechanism has some nice advantages. It allows us to easily navigate between our Javascript SPA which uses Django REST Framework, regular Django admin views that you may also be using, as well as the Django admin."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Using DRF's token authentication is still possible if you choose to use Session authentication for your JS frontend. For example, you may wish to allow users to make authenticated API requests to your public API using DRF Token Authentication."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"JWT is a really interesting concept and important to know about, but it doesn't seem like a practical solution for any of my use cases with Django APIs or frontends. You also can't really \"logout\" a user if you are using this solution for authentication."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"What I have described here is pretty simple scenario. It assumes that there is only one type of user and that there are no additional steps needed to make your account \"active\". Doing this would require additional logic on the Vue/Vuex side as well as the backend logic, including the User model. I also don't make use of any data from the social providers except for the user's email address."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Another thing to be aware of with this scenario is that a user can register with social authentication first, and then reset their password and login with email (I haven't implemented this client-side on this project yet). Or, you can login with an email account that was created through the Django admin and then login with a social account tied to that email. There are a lot of options for each backend in Python social auth, making it a very flexible library for handling social authentication."}]},{"type":"element","tag":"h2","props":{"id":"next-steps"},"children":[{"type":"text","value":"Next Steps"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There is a lot more work to do on this example project regarding authentication, but I hope it can help point some people in the right direction. Here are some areas that I would like to work on next:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Error handling for a bad authentication attempt"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A signup form with email confirmation, handling cases where the user trying to signup may already have signed in with social authentication"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Password reset with email"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Making use of Python Social Auth settings and options, including pipelines."}]}]},{"type":"element","tag":"h2","props":{"id":"resources"},"children":[{"type":"text","value":"Resources"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.toptal.com/django/integrate-oauth-2-into-django-drf-back-end","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.toptal.com/django/integrate-oauth-2-into-django-drf-back-end"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://yoongkang.com/blog/cookie-based-authentication-spa-django/","rel":["nofollow"]},"children":[{"type":"text","value":"https://yoongkang.com/blog/cookie-based-authentication-spa-django/"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/encode/django-rest-framework/issues/7273","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/encode/django-rest-framework/issues/7273"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/SimpleJWT/django-rest-framework-simplejwt/issues/71","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/SimpleJWT/django-rest-framework-simplejwt/issues/71"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/","rel":["nofollow"]},"children":[{"type":"text","value":"http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"the-authentication-flow","depth":2,"text":"The authentication flow"},{"id":"discussion","depth":2,"text":"Discussion"},{"id":"next-steps","depth":2,"text":"Next Steps"},{"id":"resources","depth":2,"text":"Resources"}]}},"_type":"markdown","_id":"content:2020:11:27:how-to-authenticate-django-rest-framework-from-vue-app-with-session-authentication-httponly-cookies.md","_source":"content","_file":"2020/11/27/how-to-authenticate-django-rest-framework-from-vue-app-with-session-authentication-httponly-cookies.md","_stem":"2020/11/27/how-to-authenticate-django-rest-framework-from-vue-app-with-session-authentication-httponly-cookies","_extension":"md"}]